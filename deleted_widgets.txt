./core/engine.py:    def delete(self):
./core/engine.py:            self.fs.delete()
./core/engine.py:    def delete(self):
./core/engine.py:            self._instrument.delete()
./core/engine.py:            self._instrument.delete()
./core/engine.py:        inst.delete()
./core/audio.py:    with tempfile.NamedTemporaryFile(suffix='.mid', delete=False) as mf:
./core/audio.py:    with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as wf:
./core/audio.py:            tmp = tempfile.NamedTemporaryFile(suffix='.wav', delete=False)
./app.py:            'track_deleted', 'beat_track_deleted',
./app.py:            'ts', 'cut_placements', 'paste_placements', 'delete_placements',
./app.py:        QShortcut(QKeySequence.Delete, self, self._on_delete)
./app.py:        QShortcut(Qt.Key_Backspace, self, self._on_delete)
./app.py:    def _on_delete(self):
./app.py:            self.arrangement.delete_selection()
./app.py:            self.piano_roll._delete_selected()
./app.py:        # TODO: Add beat_grid delete support when implemented
./app.py:    def delete_pattern(self, pid):
./app.py:        deleted_ids = pat_ops.delete_pattern(self.state, pid)
./app.py:            if p.id not in deleted_ids
./app.py:    def delete_beat_pattern(self, pid):
./app.py:        deleted_ids = pat_ops.delete_beat_pattern(self.state, pid)
./app.py:            if p.id not in deleted_ids
./app.py:    def delete_track(self, tid):
./app.py:        deleted_ids = trk_ops.delete_track(self.state, tid)
./app.py:            if p.id not in deleted_ids
./app.py:    def delete_beat_track(self, btid):
./app.py:        deleted_ids = trk_ops.delete_beat_track(self.state, btid)
./app.py:            if p.id not in deleted_ids
./app.py:    def delete_beat_instrument(self, iid):
./app.py:        trk_ops.delete_beat_instrument(self.state, iid)
./ops/patterns.py:"""Pattern and beat pattern create/edit/duplicate/delete operations."""
./ops/patterns.py:def delete_pattern(state, pid):
./ops/patterns.py:    Returns set of deleted placement IDs (caller should clean up
./ops/patterns.py:    deleted_placement_ids = {p.id for p in state.placements if p.pattern_id == pid}
./ops/patterns.py:    state.notify('delete_pattern')
./ops/patterns.py:    return deleted_placement_ids
./ops/patterns.py:def delete_beat_pattern(state, pid):
./ops/patterns.py:    Returns set of deleted beat placement IDs.
./ops/patterns.py:    deleted_ids = {p.id for p in state.beat_placements if p.pattern_id == pid}
./ops/patterns.py:    state.notify('delete_beat_pattern')
./ops/patterns.py:    return deleted_ids
./ops/tracks.py:"""Track, beat track, and beat instrument create/delete operations."""
./ops/tracks.py:def delete_track(state, tid):
./ops/tracks.py:    Returns set of deleted placement IDs.
./ops/tracks.py:    deleted_ids = {p.id for p in state.placements if p.track_id == tid}
./ops/tracks.py:    state.notify('delete_track')
./ops/tracks.py:    return deleted_ids
./ops/tracks.py:def delete_beat_track(state, btid):
./ops/tracks.py:    Returns set of deleted beat placement IDs.
./ops/tracks.py:    deleted_ids = {p.id for p in state.beat_placements if p.track_id == btid}
./ops/tracks.py:    state.notify('delete_beat_track')
./ops/tracks.py:    return deleted_ids
./ops/tracks.py:def delete_beat_instrument(state, iid):
./ops/note_edit.py:def delete_selected(pat, selected):
./ops/note_edit.py:def delete_note_at(pat, index, selected):
./undo.py:    # Clear selections that reference deleted objects
./ui/track_panel.py:                item.widget().deleteLater()
./ui/track_panel.py:            del_btn.clicked.connect(lambda: self.app.delete_beat_track(bt.id))
./ui/track_panel.py:        del_btn.clicked.connect(lambda: self.app.delete_track(t.id))
./ui/track_panel.py:        del_btn.clicked.connect(lambda: self.app.delete_beat_instrument(inst.id))
./ui/piano_roll.py:        """Cut selected notes (copy + delete), enter ghost mode."""
./ui/piano_roll.py:        from ..ops.note_edit import delete_selected
./ui/piano_roll.py:        self._selected = delete_selected(pat, self._selected)
./ui/piano_roll.py:    def _delete_selected(self):
./ui/piano_roll.py:        from ..ops.note_edit import delete_selected
./ui/piano_roll.py:        self._selected = delete_selected(pat, self._selected)
./ui/piano_roll.py:            self._delete_selected()
./ui/piano_roll.py:        from ..ops.note_edit import delete_note_at
./ui/piano_roll.py:        self._selected = delete_note_at(pat, i, self._selected)
./ui/arrangement.py:    def delete_selection(self):
./ui/arrangement.py:        self.state.notify('delete_placements')
./ui/arrangement.py:            self.parent_arr.app.delete_track(tid)
./ui/arrangement.py:                self.parent_arr.app.delete_beat_track(self.parent_arr.state.beat_tracks[bti].id)
./ui/pattern_list.py:                item.widget().deleteLater()
./ui/pattern_list.py:                item.widget().deleteLater()
./ui/pattern_list.py:        from ..ops.patterns import delete_pattern
./ui/pattern_list.py:        delete_pattern(self.state, pid)
./ui/pattern_list.py:        from ..ops.patterns import delete_beat_pattern
./ui/pattern_list.py:        delete_beat_pattern(self.state, pid)
