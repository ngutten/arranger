== Notes on development ==

This was written more or less entirely using Claude, partially as an experiment to see how well it would work and partially because there are some features I wanted - namely the ability to define and arrange sub-patterns easily, as well as to easily transpose them - that were missing from LMMS. The result was surprisingly good, so it felt like a waste not to share it. It probably needs a better name than 'arranger' honestly, but this is somewhat as-is.

There are some curious things that happened during the process of generating this which I'll note here for posterity or in case anyone is interested more in the development pattern than the product itself.

Opus 4.6 was used for the initial pass, making most of the program in about 23% of a session's worth of tokens. This was my second test with the Opus 4.6 model - the first being debugging another piece of code, which suggested to me that it'd be pretty inefficient. But surprisingly it got most of the way to feature-complete in a single pass. Sort of weirdly, it decided spontaneously to make this with flask rather than e.g. tkinter or PyQt5; that decision was made when it was initially checking the development environment. Since I was doing this with the web interface, it couldn't install packages, but evidently flask was available so flask is what we got. This had some consequences later on.

The only feature that wasn't present and working in the initial pass was, amusingly, and actual ability to play the thing you're working on. Saving as MIDI, MP3, etc was all fine, but no play button. I made the mistake of asking Opus 4.6 in the same context to add a play button. It totally rewrote the code and burned 63% of a session. Lesson being - its better to use a model like Sonnet for edits like that.

Following that I made a number of smaller adjustments and tweaks using Sonnet 4.5, which were successful at the cost of only a few percent of a session. These were things like UI elements being misaligned, wanting consistent right click = delete behavior both for patterns and notes, and some stuff with the piano roll scrollbar.

After playing around with that a bit, I decided I wanted something like the separate beat editor from LMMS. This was a big feature and I was concerned that if I just asked Sonnet to do it in one go it'd have a bunch of bugs or cause the code to expand too much. So I tried a pattern using Opus 4.6 to draft and implementation plan (which ended up having 5 parts), and then stepped through this plan with Sonnet. This took a few hours and was very token efficient - between the small adjustments and this new feature, including using Opus to plan, it took about 70% of a session. The new feature did increase the size of template.html by about 600 lines all told though (given that the entire rest of the editor fit under 1000 lines, this is relatively a lot).

During all of this I had a general preference set to write short 'researcher-style' code where possible. What I got looks like it was run through an obfuscator, which is a bit of a problem for anyone who wants to actually read and extend this, but turned out to be pretty efficient in terms of Claude (which had no problem with four-letter functions and two-letter variable names). Since this repo is mostly to make this particular artifact available to others and not to act as a locus of development, I'm not correcting that at this stage. It might be interesting to maintain a parallel translated code that is expanded to be more readable and documented. From a meta perspective, I'll have to think if there's some way to allow translation back and forth between compact, AI-friendly forms and the expanded, human-friendly forms in the future.

== Major refactor -> standalone Python app ==

This was interesting but a very different experience than the initial development of the web version. I had Opus do the first attempt to port the GUI over to tkinter in one shot, which worked surprisingly well but had some awkward bits (template.html was >30k tokens, so it couldn't read it all at once). That consumed a full session and about $6 of API credits on top of that, and resulted in something where you could only see one piano roll note at a time, the beat map grid was scrunched up, you couldn't drag and drop patterns onto the timeline, and the interface flickered horribly every time you did anything. Rather than try to fix that in place, I spent part of another session pivoting it over to PySide6 in pieces - I gave it a couple UI files and had it port them, gave it a couple more and had it port them, etc (Sonnet rather than Opus). This mostly worked with some awkwardness where it turned out it was really important to know something in app.py to get the UI stuff to link up correctly, but this did more or less manage the context size and prevent too much token wastage.

Following that I ended up in a bit of debug hell trying to fix a few outstanding issues. One thing I've found with these tools is that there's a very strong 90/10 principle, or maybe its more like 99/1 here - you can spend more resources fixing the last little bits than writing the entire thing from scratch. Part of this is context rot when contexts grow through repeated debug cycles (and possibly due to the negative valence of the conversation as a whole?). One warning sign is that when it starts making errors in matching up parentheses or curly braces, you should start a fresh context. But another part is the eager 'I know what's wrong!' type of guessing that generate a lot of short and useless iterations that end up expanding the code and context. Here I found that asking 'what can I do to help you debug this?' seems to bias the conversation towards 'find out what's wrong' rather than 'tell me what's wrong' and escapes some of the over-eager guessing behavior. I found this out after five or six back and forths over 'no, the song isn't actually stopping playback when its over and there's no indicator of the play position'. Once I asked to be included in the debugging, it led to a bunch of checks being placed in the code which diagnosed the error more precisely. Of course people talk about writing lots of tests with this sort of development which is the same spirit, but its just whether you anticipate the potential bug in advance versus having to diagnose a bug after the fact.

Another thing that can be useful is to just say 'rewrite the code using a different approach' - for a human developer that's painfully expensive, for an LLM it's sometimes cheaper and easier than debugging what you currently have. I had to do this for the drag and drop behavior of the patterns. After many iterations claiming 'yes, it should drag and drop now' including with the 'let me help you debug it' approach, there was very little change. Asking 'just convert it to click-to-add' solved it in one pass.

The advantage of going to the standalone version, aside from convenience and security, is realtime synthesis. For that I planned to use Opus to plan and Sonnet to implement, much like with the beatmap feature. The first attempt to do so got stuck on nasty static-filled playback and buffer overruns that the debugging methods I had previously tried failed at resolving, so I started over and tried using Opus for the implementation as well. This did work, though it cost about a session and $4 in API charges in excess beyond that. A lot of the problems in the original Sonnet attempt just did not manifest this time (though I did note them in advance to Opus), and the workflow had more in the way of explicit testing of audio engine features though for the most part those tests passed immediately on being written. 
